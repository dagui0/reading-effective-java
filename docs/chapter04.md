# 이펙티브 자바 (3판) - 4장 클래스와 인터페이스

## 목차

* [**아이템 15**: 클래스와 멤버의 접근 권한을 최소화하라](#아이템-15-클래스와-멤버의-접근-권한을-최소화하라)
* [**아이템 16**: `public` 클래스에서는 `public` 필드가 아닌 접근자 메서드를 사용하라](#아이템-16-public-클래스에서는-public-필드가-아닌-접근자-메서드를-사용하라)
* [**아이템 17**: 변경 가능성을 최소화하라](#아이템-17-변경-가능성을-최소화하라)
  * [**[추가]** `List.of()`, `List.copyOf()`](#추가-listof-listcopyof)
  * [**[추가]**  Guava에는 변경 불가능한 기본(primitive) 자료형 배열 클래스가 있음](#추가-guava에는-변경-불가능한-기본primitive-자료형-배열-클래스가-있음)
* [**아이템 18**: 상속보다는 컴포지션을 사용하라](#아이템-18-상속보다는-컴포지션을-사용하라)
* [**아이템 19**: 상속을 고려해 설계하고 문서화하라, 그러지 않았다면 상속을 금지하라](#아이템-19-상속을-고려해-설계하고-문서화하라-그러지-않았다면-상속을-금지하라)
  * [**[추가]** 상속관련 토론 주제: 어노테이션 드리븐 개발과 관련 문제](#추가-상속관련-토론-주제-어노테이션-드리븐-개발과-관련-문제)
* [**아이템 20**: 추상 클래스보다는 인터페이스를 우선하라](#아이템-20-추상-클래스보다는-인터페이스를-우선하라)
* [**아이템 21**: 인터페이스는 구현하는 쪽을 생각해 설계하라](#아이템-21-인터페이스는-구현하는-쪽을-생각해-설계하라)
* [**아이템 22**: 인터페이스는 타입을 정의하는 용도로만 사용하라](#아이템-22-인터페이스는-타입을-정의하는-용도로만-사용하라)
* [**아이템 23**: 태그 달린 클래스보다는 클래스 계층구조를 활용하라](#아이템-22-인터페이스는-타입을-정의하는-용도로만-사용하라)
* [**아이템 24**: 멤버 클래스는 되도록 `static`으로 만들라](#아이템-23-태그-달린-클래스보다는-클래스-계층구조를-활용하라)
* [**아이템 25**: 톱레벨 클래스는 한 파일에 하나만 담으라](#아이템-24-멤버-클래스는-되도록-static으로-만들라)

## 아이템 15: 클래스와 멤버의 접근 권한을 최소화하라

> > 높은 응집도와 낮은 결합도 High Cohesion and Loose Coupling \
> > -- Larry Constantine
> 
> 구조적 프로그래밍 이론이 정립된 1970년대부터 높은 응집도와 낮는 결합도는 프로그램 설계의 가장 기본적인 원칙이다. \
> -- 조성조

* [Larry Constantine (1943 ~ )](https://en.wikipedia.org/wiki/Larry_Constantine) - 구조적 프로그래밍 이론을 만든 분들

### 캡슐화(Encapsulation), 정보 은닉(Information Hiding)

* 빠르다 - 병렬 개발이 가능함
* 쉽다 - 모듈별로 독립적이기 때문에 디버깅, 수정, 최적화, 교체등이 쉽다
* 재사용성이 높아진다.
* 큰 시스템을 설계하는데 난이도를 낮춰준다.

정보 은닉을 위한 방법은 접근 제한을 가능한 높게 만들어 접근 가능한 코드를 최소한으로 줄여야 한다는 것

* 클래스
  * `public` - API의 일부가 됨. 영원히 하위 호환을 신경써야 한다.
  * package-private - 모듈 내부용으로만 사용할 클래스들로 언제든 변경하거나 교체해도 된다.
  * `private` 내부 클래스 - 부모 클래스 내부에서만 사용할 클래스.
* 멤버, 메소드, 중첩 클래스, 중첩 인터페이스
 * `private` - 클래스 내부에서만 사용
 * package-private - 같은 패키지에서만 사용
 * `protected` - 같은 패키지와 하위 클래스에서 사용 (package-private을 포함한다.)
 * `public` - 어디서든 사용 가능

package-private에서 `protected` 단계로 가면 접근 허용 범위가 엄청나게 넓어지는 것이다. `protected`는 공개 API의 일부분이다.


## 아이템 16: `public` 클래스에서는 `public` 필드가 아닌 접근자 메서드를 사용하라


## 아이템 17: 변경 가능성을 최소화하라


### **[추가]** `List.of()`, `List.copyOf()`

Java 9 부터 `Collections.unmodifiableList()`를 대체할 수 있는 `List.of()`, `List.copyOf()` 추가됨.
당연한 이야기지만 `Set.of()` 등도 있음.

* `<E> List<E> of(E e1, E e2)` - 최소 0 ~ 최대 10개까지 메소드가 준비되어 있음
* `<E> List<E> of(E... elements)`
* `<E> List<E> copyOf(Collection<? extends E> coll)`
* `<K,V> Map<K,V> of(K k1, V v1, K k2, V v2)` - 최소 0 ~ 최대 10쌍까지 메소드가 준비되어 있음
* `<K,V> Map<K,V> ofEntries(Map.Entry<? extends K,? extends V>... entries)`
* `<K,V> Map<K,V> copyOf(Map<? extends K,? extends V> map)`

### **[추가]**  Guava에는 변경 불가능한 기본(primitive) 자료형 배열 클래스가 있음

* [Guava: Google Core Libraries for Java](https://github.com/google/guava)
* [Guava API docs](https://guava.dev/releases/22.0/api/docs/)
* [Guava를 써야하는 5가지 이유](https://blog.outsider.ne.kr/710)

```java
import com.google.common.primitives.ImmutableIntArray;

@Test
public void testImmutableIntArray() {
    ImmutableIntArray arr = ImmutableIntArray.of(1, 2, 3);

    assertEquals(1, arr.get(0));
}
```

## 아이템 18: 상속보다는 컴포지션을 사용하라


## 아이템 19: 상속을 고려해 설계하고 문서화하라, 그러지 않았다면 상속을 금지하라


### **[추가]** 상속관련 토론 주제: 어노테이션 드리븐 개발과 관련 문제

[lombok](https://projectlombok.org/) 같이 어노테이션을 이용해서 코드를 자동 확장하는 경우.
설사 어노테이션 프로세서가 내부적으로 상속 메커니즘을 이용하지 않는다 해도, 상속과 같은 것이라고 할 수 있다.

이런 경우에는 상속을 피하라는 규칙에 위배된다고 볼 수 있을까? (계엄령의 근거가 될 수 있을까?)

멤버 의견:
* Alejandro: 
* Leeturn:
* Scully:
* Lucie:

## 아이템 20: 추상 클래스보다는 인터페이스를 우선하라


## 아이템 21: 인터페이스는 구현하는 쪽을 생각해 설계하라


## 아이템 22: 인터페이스는 타입을 정의하는 용도로만 사용하라


## 아이템 23: 태그 달린 클래스보다는 클래스 계층구조를 활용하라


## 아이템 24: 멤버 클래스는 되도록 `static`으로 만들라


## 아이템 25: 톱레벨 클래스는 한 파일에 하나만 담으라

