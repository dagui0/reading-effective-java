# Vibe Coding 간이 스페셜

## 정의

* 생성형 인공지능의 도움을 받아 코드를 작성하는 행위
* 엄밀한 설계나 계획을 바탕으로 진행하는 것이 아니라, 직감과 느낌에 의존한다는 의미
* vibration(진동) -> 공명/아우라 -> vibe(느낌, 분위기)
* 2025년 안드레 카파시가 처음 트위터에서 처음 개념을 제시한 것에서 유래함

> There's a new kind of coding I call "vibe coding",
> where you fully give in to the vibes, embrace exponentials,
> and forget that the code even exists.
> It's possible because the LLMs (e.g. Cursor Composer w Sonnet) are getting too good.
> Also I just talk to Composer with SuperWhisper so I barely even touch the keyboard.
> I ask for the dumbest things like "decrease the padding on the sidebar by half"
> because I'm too lazy to find it.
> I "Accept All" always, I don't read the diffs anymore.
> When I get error messages I just copy paste them in with no comment,
> usually that fixes it. The code grows beyond my usual comprehension,
> I'd have to really read through it for a while.
> Sometimes the LLMs can't fix a bug so I just work around it or ask for random changes
> until it goes away. It's not too bad for throwaway weekend projects,
> but still quite amusing.
> I'm building a project or webapp, but it's not really coding - I just see stuff,
> say stuff, run stuff, and copy paste stuff, and it mostly works.
> 
> "바이브 코딩"이라고 부르는 새로운 종류의 코딩이 있는데,
> 분위기에 완전히 몰입하고, 지수 함수적인 변화를 받아들이고,
> 코드가 존재한다는 사실조차 잊어버리는 거죠.
> LLM(예: Cursor Composer w Sonnet)이 너무 좋아져서 가능한 일이죠.
> 또한, 저는 SuperWhisper로 Composer에 명령하기 때문에 키보드를 거의 만지지 않아요.
> "사이드바 패딩을 절반으로 줄여줘" 같은 멍청한 요청도 해요.
> 너무 귀찮아서요.
> 저는 항상 "모두 수락"을 하고, 더 이상 차이점을 읽지 않아요.
> 오류 메시지가 나타나면 주석 없이 복사해서 붙여넣기만 하면 돼요.
> 보통은 이렇게 해결되죠. 하지만 코드가 평소보다 더 길어져서
> 한참 동안 꼼꼼히 읽어봐야 할 것 같아요.
> 가끔 LLM에서 버그를 수정하지 못할 때가 있어서, 그냥 해결하거나 무작위로 수정 요청을 하기도 합니다.
> 버그가 사라질 때까지요. 덧없이 쓰는 주말 프로젝트로는 나쁘지 않지만,
> 그래도 꽤 재밌습니다.
> 프로젝트나 웹앱을 만들고 있는데, 코딩은 아니에요. 그냥 보고,
> 말하고, 실행하고, 복사해서 붙여넣기만 하면 되는데, 대부분 잘 됩니다.
> 
> 2025-02-03 @karpathy (Andrej Karpathy)

## 장단점

### 장점

* 생산성 향상과 개발 속도 단축
* 지식을 갖춘자
  * 실수를 줄이고 피드백을 잘 받아들여서 코드의 품질을 높일 수 있음
  * 특히 프로토타이핑이나 간단한 기능 구현 단계에서 효과가 두드러짐
* 지식이 부족한 자
  * 시도조차 불가능했을 어려운 문제에 대한 해결책을 제시받을 수 있음
  * 대화형으로 문제를 구체화하고 발전 시킬 수 있음
* 데이터 가공 등 루틴화된 작업에 적용하면 크게 효과적 

### 단점

* 비야네 스트로스트룹 (C++ 저자)
  * 이전에 잘못된 코드들이 학습되어 바람직하지 않은 코드를 제시할 수 있음
  * 개발자들이 생각을 하지 않고 코드를 작성하는 습관을 만들 수 있음
* 초심자들에게 설계 없이 일단 짜고 보자는 방식의 접근을 유도할 수 있음
* 부분적으로 "이거해줘"로 얻은 코드를 붙여 넣어 단지 작동하기만 하는 코드가 나올 수 있음
* "이 코드를 왜 이렇게 작성하셨나요?"에 답할 수 없음

## Gemini Advanced (2.5 Pro) 경험담

### 2.5 Pro 기능 현황

* 2.5 Flash(빠른 단답 위주)와 2.5 Pro(추론 위주)의 답변 퀄리티 차이가 매우 큼
* 단 2.5 Pro는 현 시점에서 Experimental 기능이므로, 서비스 퀄리티는 만족스럽지 못함 (빠르게 개선되고 있기는 함)
* 생각하다가 시간이 너무 오래 걸리면 최종 답변 생성 + 번역을 못하고 답변이 종료되는 경우가 있었음 (생각하는 과정을 보면 답변 내용도 다 준비가 된 상태)
  * 수정됨: 오류 건수도 많이 줄었고, 타임아웃을 설정한듯 하며, "LLM으로 그것은 처리할 수 없다"는 복붙 메시지가 뜸
* 컨텍스트 토큰 수가 매우 크지만 대화 스레드가 길어지면 반드시 이런 저런 문제가 발생함
  * 앞서 이야기한 내용과 다른 내용을 제안하기도 하고, 알고 있던 내 의도를 잊어버리기도 함
  * 외부 검색이 필요한 내용을 질문한 경우 내부적으로 처리 모델이 바뀌는지 앞뒤 내용과 어울리지 않는 답변을 하기도 함
  * 새 창을 열면 프로젝트 의도와 진행 상황 등 바닥부터 다시 대화를 시작해야함
* DeepResearch 기능
  * 인터넷 검색을 통해 조사하고 요약하는데 포커스가 맞춰져 있고, 코드 리뷰에는 별 관심이 없는듯 함.

### 다수 파일 업로드 기능

* 여러 파일을 동시에 업로드하여 전반적인 검토를 요청하면, 총평을 해줌
  * 단, 1회 답변 길이에 제한이 있는듯 하며, 크게 유용한 검토는 안되는 듯 함
* 파일을 업로드하면 기존의 컨텍스트와 엉켜서 이후 답변이 문제가 많이 발생함
  * 파일을 첨부하여 질문을 한 이후, 다시 다른 질문을 하면 이전 질문에 대한 답변을 반복하거나, 이전에 첨부한 코드와 지금 질문을 섞어서 인식함
    * 한번 첨부된 파일은 질문 컨텍스트에 항상 입력으로 포함되는 듯 
  * 마지막으로 작업한 파일을 업로드해서 찬사를 받은 후 창을 종료하는 용도
* 파일 업로드 대신, github 링크를 줄 수도 있음

### 캔버스(Canvas) 기능

* 답변 내용을 별도의 완결성 있는 짧은 문서로 정리하여 추후 참조할 수 있도록 해줌
* 코드 리팩토링이 어러차례 진행되는 경우 새로운 문서를 만드는 것이 아니라 기존 캔버스의 버전을 높이는데
  찾아보기 좋도록 한다는 의도가 옅어지는 측면이 있음

### 제안, 리뷰, 답변의 퀄리티

* 상당히 만족스럽고, 디자인 패턴, 네이밍, 업계 관행 등도 조언을 해줌
  * 만약 리팩토링에 관심이 있다면 아주 좋음
* 로직상의 버그도 잘 찾아주는 편
  * 하지만 모든 경우를 다 검토해서 버그를 잡지는 못하고, 테스트는 필수

### 사용 후기

* "코딩을 책으로 배웠어요" - 실제 실행을 해보지는 못하기 때문에 결과를 100%알지 못함
* "박사 출신 신입사원" - 업무상 경험에서 나온 의도를 캐치 못하고 리팩토링하라고 강권함
* "페어 프로그래밍이란 이런 것이구나" - 내 코드를 항상 보고 검토해주는 누군가가 있다는 것은 아주 좋다는 생각이 듬
* "생산성 향상"은 개뿔 리팩토링의 끝으로 파고들게됨 -> 사용자의 개인적인 성향과도 관련있는 듯
* "도전할 엄두도 없던 일을 도전하게함" -> 이건 분명히 맞음. 그냥 이런게 필요한데 하면 코드의 스켈레톤을 만들어서 보여줌
  * 구글 검색 및 사전 스터디를 확실하게 대체 가능함

### 터득한 요령

* 하위 패키지당 1개 이상 대화 스레드를 만들어서 컨텍스트를 의도적으로 관리해줘야 함
  * 한번 새로운 대화창으로 이동하고 나면 과거 대화창으로 돌아가서 이어서 질문하고 하는 것이 잘 되지 않음
    * 왜냐하면 내 생각은 더 발전했는데 예전 대화창은 과거에 머물고 있기 때문
* 새로운 창을 열 때는 항상 그 창의 내용을 정리해서 코드에 어느정도 반영하고 다음으로 넘어가는 것이 필요
  * 대화를 통해 발전하는 부분이 분명하게 있으나 캔버스는 스케치 또는 참고자료 정도이고, 최종 산출물을 정리하는 것은 사용자의 책임
